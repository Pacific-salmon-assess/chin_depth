### ROMS Data Clean
## Export stations for query, then import and evaluate 
## Query conducted by Doug Jackson (doug@qedaconsulting.com)
## Feb 14, 2022

library(tidyverse)

# receiver data (includes bathymetric data generated in chin_tagging repo)
rec <- readRDS(here::here("data", "receivers_all.RDS"))$rec_all 

# moderately cleaned detections data (includes depth/temperature sensors)
depth_raw <- readRDS(here::here("data", "detections_all.RDS")) %>%
  filter(!is.na(depth),
         depth > 0) %>% 
  left_join(., rec %>% rename(receiver = receiver_name), by = "receiver") %>% 
  select(vemco_code, date_time, latitude, longitude)

# B. Hendricks data
depth_h <- readRDS(here::here("data", "hendricks_depth_dets.RDS")) %>% 
  select(vemco_code, date_time, latitude, longitude)

# add coordinates in UTM space
lonlat_to_utm <- function(x, y, zone){
  xy <- data.frame(ID = 1:length(x), X = x, Y = y)
  sp::coordinates(xy) <- c("X", "Y")
  sp::proj4string(xy) <- sp::CRS("+proj=longlat +datum=WGS84")  ## for example
  res <- sp::spTransform(
    xy, 
    sp::CRS(
      paste("+proj=utm +zone=",zone," +units=m +datum=WGS84 ellps=WGS84",
            sep = '')
      
    ))
  return(as.data.frame(res))
}


## EXPORT STATIONS -------------------------------------------------------------

# calculate sample size for ROMS pull assuming hourly bins for each receiver and
# either continuous (first to last detection) or gappy coverage

depth_dets1 <- rbind(depth_raw, depth_h) %>% 
  mutate(
    hour = lubridate::hour(date_time) + 1,
    day = lubridate::day(date_time),
    month = lubridate::month(date_time),
    year = lubridate::year(date_time)
  ) 


# infill to make continuous for each receiver based on first/last detection
# currently unused
# depth_dat_infill <- split(depth_dets1, depth_dets1$receiver) %>% 
#   purrr::map(., function (x) {
#     min_day <- format(round(min(x$date_time), units = "hours"))
#     max_day <- format(round(max(x$date_time) + 3600, units = "hours"))
#     time_seq <- seq.POSIXt(as.POSIXct(min_day), as.POSIXct(max_day), 
#                            by = "1 hour")
#     data.frame(
#       date_time = time_seq,
#       receiver = unique(x$receiver),
#       latitude = unique(x$latitude),
#       longitude = unique(x$longitude)
#     ) %>% 
#       mutate(
#         hour = lubridate::hour(date_time) + 1,
#         day = lubridate::day(date_time),
#         month = lubridate::month(date_time),
#         year = lubridate::year(date_time)
#       ) 
#   }) %>% 
#   bind_rows()


# expand depth dets by different covariates and depths
trim_dets <- depth_dets1 %>% 
  select(year, month, day, hour, lat = latitude, lon = longitude) %>% 
  distinct()
var_list <- c("u", "v", "w", "temp", "zooplankton", "rho")
# focus on one depth given strong correlations among them
depth_list <- c(#5, 
  25#, 50
  )

roms_dat_out <- expand.grid(
  variable = var_list,
  depth = depth_list
) %>% 
  mutate(
    # depth = ifelse(variable == "w", -999, depth),
    fac = paste(variable, depth, sep = "_")
  ) %>% 
  distinct() %>% 
  split(., .$fac) %>% 
  purrr::map(., function (x) {
    trim_dets %>% 
      mutate(variable = x$variable,
             depth = x$depth)
  }) %>% 
  bind_rows %>% 
  mutate(depthFrac = -999) %>% 
  dplyr::select(year, month, day, hour, variable, lat,
                lon, depth, depthFrac) 


# export 
write.csv(roms_dat_out, here::here("data", "stations_roms_no_infill.csv"),
          row.names = FALSE)


## IMPORT ROMS PULL ------------------------------------------------------------

# query generated by Doug; note some stations have missing values due to outside
# survey domain
# Feb pull has multiple depths, but March does not because highly correlated 
# with one another

roms_dat <- read.csv(
  here::here("data", "stations_roms_no_infill_25mar22_all.csv")) %>%
  # here::here("data", "stations_roms_no_infill_10feb22_all.csv")) %>%
  distinct()


# histogram of values by depth and variable
# ggplot(roms_dat) +
#   geom_histogram(aes(x = value)) +
#   facet_wrap(~variable, scales = "free") +
#   ggsidekick::theme_sleek()
# 
# 
# # evaluate correlations between depth strata for each variable
# wide_roms <- roms_dat %>%
#   pivot_wider(names_from = "depth", names_prefix = "depth_",
#               values_from = "value") %>%
#   filter(!is.na(depth_25))
# 
# corr_list <- wide_roms %>%
#   split(., .$variable) %>%
#   purrr::map2(., names(.), function (x, y) {
#     corr <- cor(x %>% select(depth_5, depth_25, depth_50))
#     ggcorrplot::ggcorrplot(corr) +
#       labs(title = y)
#   })
# # u and v highly correlated through depth range; w not correlated at all;
# # zooplankton shows correlations at 25 m; use 25 for now

roms_25 <- roms_dat %>%
  left_join(., 
            rec %>% 
              select(lat = station_latitude, lon = station_longitude,
                     region, mean_depth, mean_slope, shore_dist) %>% 
              distinct(),
            by = c("lat", "lon")) %>% 
  filter(depth == "25",
         !region == "fraser") %>%
  pivot_wider(names_from = "variable", values_from = "value") %>%
  rename(zoo = zooplankton, latitude = lat, longitude = lon,
         hour_int = hour, roms_temp = temp) %>%
  # add time step variable used during imputation
  mutate(
    date = paste(day, month, year, sep = "-"),
    time = paste(hour_int, "00", sep = ":"),
    time1 = as.POSIXct("01-07-2019 12:00", form = "%d-%m-%Y %H:%M"),
    timestamp = paste(date, time, sep = " ") %>% 
      as.POSIXct(., form = "%d-%m-%Y %H:%M") %>%
      difftime(time1, timestamp) %>% 
      as.numeric()
  ) %>% 
  select(-depth, -depthFrac, -c(date:time1))

depth_utm <- lonlat_to_utm(roms_25$longitude, roms_25$latitude, 
                           zone = 10) 
roms_25$utm_x <- depth_utm$X / 1000 
roms_25$utm_y <- depth_utm$Y / 1000

# identify proportion fo NA by each ROMS variable
roms_25 %>% 
  pivot_longer(., cols = c(v:zoo), names_to = "roms_var") %>% 
  filter(is.na(value)) %>% 
  group_by(roms_var) %>% 
  tally() %>% 
  mutate(n / nrow(roms_25))
  

# missing values due to a) unavailable data and b) delays between ROMS pulls

# join with receiver data (includes bathymetric variables) and impute using
# k nearest neighbors
# NOTE not all current ROMS pulls have associated receiver data but this will be 
# corrected by next extraction

roms_25[roms_25 == "-999"] <- NA

# roms_interp <- VIM::kNN(roms_25,
#                         variable = c("v", "u", "rho", "roms_temp", "w", "zoo"),
#                         dist_var = c("timestamp", "utm_x", "utm_y"),
#                         k = 5)
roms_interp2 <- VIM::kNN(roms_25,
                        variable = c("v", "u", "rho", "roms_temp", "w", "zoo"),
                        dist_var = c("timestamp", "utm_x", "utm_y",
                                     "mean_depth", "mean_slope", "shore_dist"),
                        k = 5)

ggplot() +
  geom_boxplot(data = roms_interp,
              aes(x = as.factor(month), y = u, fill = u_imp)) +
  ggsidekick::theme_sleek() +
  facet_wrap(~region)


# remove flags and non-ROMS data
roms_interp_trim <- roms_interp %>% 
  select(year:longitude, v:zoo) %>% 
  glimpse()


saveRDS(roms_interp_trim, 
        here::here("data", "interp_roms_25m_depth_v2.RDS"))




## MISC EXPLORATIONS -----------------------------------------------------------

# look at correlations with other explanatory variables
tt <- readRDS(here::here("data", "depth_dat_nobin.RDS")) %>% 
  mutate(hour_int = lubridate::hour(date_time) + 1,
         day = lubridate::day(date_time),
         month = lubridate::month(date_time),
         year = lubridate::year(date_time))  %>%
  select(-(u:zoo)) %>% 
  left_join(
    ., roms_25, 
    by = c("latitude", "longitude", "day", "month", "year", "hour_int")
  )

corr_tt <- cor(tt %>% select(latitude:shore_dist, det_day, u:v, rho),
               use = "complete.obs")
ggcorrplot::ggcorrplot(corr_tt)
# correlations negligible


length(tt$latitude[!is.na(tt$latitude)])
length(tt$mean_bathy[!is.na(tt$mean_bathy)])
length(tt$u[!is.na(tt$u)])
length(tt$v[!is.na(tt$v)])
length(tt$zoo[!is.na(tt$zoo)])
length(tt$w[!is.na(tt$w)])
length(tt$rho[!is.na(tt$rho)])
length(tt$roms_temp[!is.na(tt$roms_temp)])
# ~3k fewer ROMS detections than other variables; ~30k fewer for zoo (consider
# removing)


# visualize relationships
tt %>% 
  select(stage, region_f, pos_depth, rel_depth, u, v, w, zoo, rho) %>%
  pivot_longer(cols = c(u:rho), names_to = "var", values_to = "value") %>% 
  ggplot(.) +
  geom_point(aes(x = value, y = pos_depth, fill = stage), shape = 21) +
  facet_grid(region_f ~ var, scales = "free") +
  ggsidekick::theme_sleek()



